package com.blocklegend001.expore.datagen;

import com.blocklegend001.expore.blocks.ModBlocks;
import net.minecraft.client.data.models.BlockModelGenerators;
import net.minecraft.client.data.models.ItemModelGenerators;
import net.minecraft.client.data.models.ModelProvider;
import net.minecraft.client.data.models.blockstates.MultiVariantGenerator;
import net.minecraft.client.data.models.blockstates.Variant;
import net.minecraft.client.data.models.blockstates.VariantProperties;
import net.minecraft.client.data.models.model.*;
import net.minecraft.client.renderer.item.BlockModelWrapper;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.data.CachedOutput;
import net.minecraft.data.PackOutput;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.Item;
import net.minecraft.world.level.block.Block;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.stream.Stream;

public class ModModelGenerator extends ModelProvider {
    private final PackOutput.PathProvider blockStatePathProvider;
    private final PackOutput.PathProvider itemInfoPathProvider;
    private final PackOutput.PathProvider modelPathProvider;
    protected final String modId;

    public ModModelGenerator(PackOutput packOutput, String modId) {
        super(packOutput);
        this.blockStatePathProvider = packOutput.createPathProvider(PackOutput.Target.RESOURCE_PACK, "blockstates");
        this.itemInfoPathProvider = packOutput.createPathProvider(PackOutput.Target.RESOURCE_PACK, "items");
        this.modelPathProvider = packOutput.createPathProvider(PackOutput.Target.RESOURCE_PACK, "models");
        this.modId = modId;
    }

    protected void registerModels(BlockModelGenerators blockModels, ItemModelGenerators itemModels) {
       normalBlock(blockModels, ModBlocks.EXP_ORE.get());
       normalBlock(blockModels, ModBlocks.DEEPSLATE_EXP_ORE.get());
       normalBlock(blockModels, ModBlocks.NETHER_EXP_ORE.get());
       normalBlock(blockModels, ModBlocks.END_EXP_ORE.get());
    }

    public void normalBlock(BlockModelGenerators blockModels, Block block) {
        try {
            // Usa riflessione per accedere ai metodi protetti e ai campi
            Method createSimpleBlockMethod = BlockModelGenerators.class.getDeclaredMethod("createSimpleBlock", Block.class, ResourceLocation.class);
            createSimpleBlockMethod.setAccessible(true);

            Field modelOutputField = BlockModelGenerators.class.getDeclaredField("modelOutput");
            Field blockStateOutputField = BlockModelGenerators.class.getDeclaredField("blockStateOutput");
            Field itemModelOutputField = BlockModelGenerators.class.getDeclaredField("itemModelOutput");

            modelOutputField.setAccessible(true);
            blockStateOutputField.setAccessible(true);
            itemModelOutputField.setAccessible(true);

            // Ottieni i valori dei campi
            BiConsumer<ResourceLocation, ModelInstance> modelOutput = (BiConsumer<ResourceLocation, ModelInstance>) modelOutputField.get(blockModels);
            Consumer<MultiVariantGenerator> blockStateOutput = (Consumer<MultiVariantGenerator>) blockStateOutputField.get(blockModels);
            BiConsumer<Item, BlockModelWrapper.Unbaked> itemModelOutput = (BiConsumer<Item, BlockModelWrapper.Unbaked>) itemModelOutputField.get(blockModels);

            // Generazione modelli
            ResourceLocation id = Objects.requireNonNull(BuiltInRegistries.BLOCK.getKey(block));
            String parent = id.getPath().replace("_block", "");
            ResourceLocation parentTexture = ResourceLocation.withDefaultNamespace("block/" + parent);

            TextureMapping textureMapping = new TextureMapping().put(TextureSlot.ALL, parentTexture);
            ResourceLocation blockAllModel = ModelTemplates.CUBE_ALL.create(block, textureMapping, modelOutput);

            // Chiamata al metodo riflesso
            createSimpleBlockMethod.invoke(blockModels, block, blockAllModel);

            itemModelOutput.accept(block.asItem(), new BlockModelWrapper.Unbaked(this.blockStateLocation(id), Collections.emptyList()));
        } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | java.lang.reflect.InvocationTargetException e) {
            throw new RuntimeException("Errore durante l'accesso ai metodi e campi protetti di BlockModelGenerators", e);
        }
    }

    private ResourceLocation blockStateLocation(ResourceLocation id) {
        return ResourceLocation.fromNamespaceAndPath(id.getNamespace(), "block/" + id.getPath());
    }

    @Override
    public CompletableFuture<?> run(CachedOutput output) {
        ItemInfoCollector itemCollector = new ItemInfoCollector(this::getKnownItems);
        BlockStateGeneratorCollector blockStateCollector = new BlockStateGeneratorCollector(this::getKnownBlocks);
        SimpleModelCollector simpleModelCollector = new SimpleModelCollector();
        this.registerModels(new BlockModelGenerators(blockStateCollector, itemCollector, simpleModelCollector), new ItemModelGenerators(itemCollector, simpleModelCollector));
        blockStateCollector.validate();
        itemCollector.finalizeAndValidate();
        return CompletableFuture.allOf(
                blockStateCollector.save(output, this.blockStatePathProvider),
                simpleModelCollector.save(output, this.modelPathProvider),
                itemCollector.save(output, this.itemInfoPathProvider)
        );
    }

    @Override
    protected Stream<Block> getKnownBlocks() {
        return BuiltInRegistries.BLOCK.stream()
                .filter((block) -> Optional.of(BuiltInRegistries.BLOCK.getKey(block))
                        .filter((key) -> key.getNamespace().equals(this.modId))
                        .isPresent());
    }

    @Override
    protected Stream<Item> getKnownItems() {
        return BuiltInRegistries.ITEM.stream()
                .filter((item) -> Optional.of(BuiltInRegistries.ITEM.getKey(item))
                        .filter((key) -> key.getNamespace().equals(this.modId))
                        .isPresent());
    }
}
